/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { CdkTreeNode, CdkTreeNodeDef } from '@angular/cdk/tree';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, Input, Renderer2, ViewContainerRef } from '@angular/core';
import { NzTreeView } from './tree';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './tree';

function NzTreeNodeComponent_nz_tree_node_indents_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nz-tree-node-indents", 2);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("indents", ctx_r0.indents);
} }
function NzTreeNodeComponent_nz_tree_node_toggle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nz-tree-node-toggle", 3);
    ɵngcc0.ɵɵelement(1, "span", 4);
    ɵngcc0.ɵɵelementEnd();
} }
const _c0 = [[["nz-tree-node-toggle"], ["", "nz-tree-node-toggle", ""]], [["nz-tree-node-checkbox"]], [["nz-tree-node-option"]], "*"];
const _c1 = ["nz-tree-node-toggle, [nz-tree-node-toggle]", "nz-tree-node-checkbox", "nz-tree-node-option", "*"];
export class NzTreeNodeComponent extends CdkTreeNode {
    constructor(elementRef, tree, renderer, cdr) {
        super(elementRef, tree);
        this.elementRef = elementRef;
        this.tree = tree;
        this.renderer = renderer;
        this.cdr = cdr;
        this.indents = [];
        this.disabled = false;
        this.selected = false;
        this.isLeaf = false;
        this._elementRef.nativeElement.classList.add('ant-tree-treenode');
    }
    ngOnInit() {
        this.isLeaf = !this.tree.treeControl.isExpandable(this.data);
    }
    disable() {
        this.disabled = true;
        this.updateDisabledClass();
    }
    enable() {
        this.disabled = false;
        this.updateDisabledClass();
    }
    select() {
        this.selected = true;
        this.updateSelectedClass();
    }
    deselect() {
        this.selected = false;
        this.updateSelectedClass();
    }
    setIndents(indents) {
        this.indents = indents;
        this.cdr.markForCheck();
    }
    updateSelectedClass() {
        if (this.selected) {
            this.renderer.addClass(this.elementRef.nativeElement, 'ant-tree-treenode-selected');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'ant-tree-treenode-selected');
        }
    }
    updateDisabledClass() {
        if (this.disabled) {
            this.renderer.addClass(this.elementRef.nativeElement, 'ant-tree-treenode-disabled');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'ant-tree-treenode-disabled');
        }
    }
}
NzTreeNodeComponent.ɵfac = function NzTreeNodeComponent_Factory(t) { return new (t || NzTreeNodeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NzTreeView), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NzTreeNodeComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NzTreeNodeComponent, selectors: [["nz-tree-node", 3, "builtin", ""]], hostVars: 4, hostBindings: function NzTreeNodeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("ant-tree-treenode-switcher-open", ctx.isExpanded)("ant-tree-treenode-switcher-close", !ctx.isExpanded);
    } }, exportAs: ["nzTreeNode"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkTreeNode, useExisting: NzTreeNodeComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 6, vars: 2, consts: [[3, "indents", 4, "ngIf"], ["class", "nz-tree-leaf-line-icon", "nzTreeNodeNoopToggle", "", 4, "ngIf"], [3, "indents"], ["nzTreeNodeNoopToggle", "", 1, "nz-tree-leaf-line-icon"], [1, "ant-tree-switcher-leaf-line"]], template: function NzTreeNodeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵtemplate(0, NzTreeNodeComponent_nz_tree_node_indents_0_Template, 1, 1, "nz-tree-node-indents", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵtemplate(2, NzTreeNodeComponent_nz_tree_node_toggle_2_Template, 2, 0, "nz-tree-node-toggle", 1);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵprojection(4, 2);
        ɵngcc0.ɵɵprojection(5, 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.indents.length);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.indents.length && ctx.isLeaf);
    } }, encapsulation: 2, changeDetection: 0 });
NzTreeNodeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NzTreeView },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NzTreeNodeComponent, [{
        type: Component,
        args: [{
                selector: 'nz-tree-node:not([builtin])',
                exportAs: 'nzTreeNode',
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: CdkTreeNode, useExisting: NzTreeNodeComponent }],
                template: `
    <nz-tree-node-indents [indents]="indents" *ngIf="indents.length"></nz-tree-node-indents>
    <ng-content select="nz-tree-node-toggle, [nz-tree-node-toggle]"></ng-content>
    <nz-tree-node-toggle class="nz-tree-leaf-line-icon" *ngIf="indents.length && isLeaf" nzTreeNodeNoopToggle>
      <span class="ant-tree-switcher-leaf-line"></span>
    </nz-tree-node-toggle>
    <ng-content select="nz-tree-node-checkbox"></ng-content>
    <ng-content select="nz-tree-node-option"></ng-content>
    <ng-content></ng-content>
  `,
                host: {
                    '[class.ant-tree-treenode-switcher-open]': 'isExpanded',
                    '[class.ant-tree-treenode-switcher-close]': '!isExpanded'
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.NzTreeView }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
export class NzTreeNodeDefDirective extends CdkTreeNodeDef {
}
NzTreeNodeDefDirective.ɵfac = /*@__PURE__*/ function () { let ɵNzTreeNodeDefDirective_BaseFactory; return function NzTreeNodeDefDirective_Factory(t) { return (ɵNzTreeNodeDefDirective_BaseFactory || (ɵNzTreeNodeDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NzTreeNodeDefDirective)))(t || NzTreeNodeDefDirective); }; }();
NzTreeNodeDefDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NzTreeNodeDefDirective, selectors: [["", "nzTreeNodeDef", ""]], inputs: { when: ["nzTreeNodeDefWhen", "when"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkTreeNodeDef, useExisting: NzTreeNodeDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NzTreeNodeDefDirective.propDecorators = {
    when: [{ type: Input, args: ['nzTreeNodeDefWhen',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NzTreeNodeDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nzTreeNodeDef]',
                providers: [{ provide: CdkTreeNodeDef, useExisting: NzTreeNodeDefDirective }]
            }]
    }], null, { when: [{
            type: Input,
            args: ['nzTreeNodeDefWhen']
        }] }); })();
export class NzTreeVirtualScrollNodeOutletDirective {
    constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
        this._viewRef = null;
    }
    ngOnChanges(changes) {
        const recreateView = this.shouldRecreateView(changes);
        if (recreateView) {
            const viewContainerRef = this._viewContainerRef;
            if (this._viewRef) {
                viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = this.data ? viewContainerRef.createEmbeddedView(this.data.nodeDef.template, this.data.context) : null;
            if (CdkTreeNode.mostRecentTreeNode && this._viewRef) {
                CdkTreeNode.mostRecentTreeNode.data = this.data.data;
            }
        }
        else if (this._viewRef && this.data.context) {
            this.updateExistingContext(this.data.context);
        }
    }
    shouldRecreateView(changes) {
        const ctxChange = changes.data;
        return !!changes.data || (ctxChange && this.hasContextShapeChanged(ctxChange));
    }
    hasContextShapeChanged(ctxChange) {
        const prevCtxKeys = Object.keys(ctxChange.previousValue || {});
        const currCtxKeys = Object.keys(ctxChange.currentValue || {});
        if (prevCtxKeys.length === currCtxKeys.length) {
            for (const propName of currCtxKeys) {
                if (prevCtxKeys.indexOf(propName) === -1) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    updateExistingContext(ctx) {
        for (const propName of Object.keys(ctx)) {
            this._viewRef.context[propName] = this.data.context[propName];
        }
    }
}
NzTreeVirtualScrollNodeOutletDirective.ɵfac = function NzTreeVirtualScrollNodeOutletDirective_Factory(t) { return new (t || NzTreeVirtualScrollNodeOutletDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
NzTreeVirtualScrollNodeOutletDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NzTreeVirtualScrollNodeOutletDirective, selectors: [["", "nzTreeVirtualScrollNodeOutlet", ""]], inputs: { data: "data" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NzTreeVirtualScrollNodeOutletDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
NzTreeVirtualScrollNodeOutletDirective.propDecorators = {
    data: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NzTreeVirtualScrollNodeOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nzTreeVirtualScrollNodeOutlet]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { data: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vY29tcG9uZW50cy90cmVlLXZpZXcvbm9kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUgsT0FBTyxFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQTRCLE1BQU0sbUJBQW1CLENBQUM7QUFDMUYsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFNBQVMsRUFDVCxVQUFVLEVBRVYsS0FBSyxFQUlMLFNBQVMsRUFHVCxnQkFBZ0IsRUFDakIsTUFBTSxlQUFlLENBQUM7QUFJdkIsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QnBDLE1BQU0sT0FBTyxtQkFBdUIsU0FBUSxXQUFjO0FBQUcsSUFNM0QsWUFDWSxVQUFtQyxFQUNuQyxJQUFtQixFQUNyQixRQUFtQixFQUNuQixHQUFzQjtBQUMvQixRQUNDLEtBQUssQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDNUIsUUFOYyxlQUFVLEdBQVYsVUFBVSxDQUF5QjtBQUFDLFFBQ3BDLFNBQUksR0FBSixJQUFJLENBQWU7QUFBQyxRQUN0QixhQUFRLEdBQVIsUUFBUSxDQUFXO0FBQUMsUUFDcEIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7QUFDbEMsUUFWRSxZQUFPLEdBQWMsRUFBRSxDQUFDO0FBQzFCLFFBQUUsYUFBUSxHQUFHLEtBQUssQ0FBQztBQUNuQixRQUFFLGFBQVEsR0FBRyxLQUFLLENBQUM7QUFDbkIsUUFBRSxXQUFNLEdBQUcsS0FBSyxDQUFDO0FBQ2pCLFFBUUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3RFLElBQUUsQ0FBQztBQUNILElBQ0UsUUFBUTtBQUFLLFFBQ1gsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FB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LFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSDtrRUFyREMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxpQ0FBaUMsY0FDNUM7a1FBQ0k7QUFBQztBQUFnRSxZQTFHcEUsZ0JBQWdCO0FBQ2hCO0FBQUc7QUFFaUMsbUJBeUduQyxLQUFLO0FBQUk7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG5pbXBvcnQgeyBDZGtUcmVlTm9kZSwgQ2RrVHJlZU5vZGVEZWYsIENka1RyZWVOb2RlT3V0bGV0Q29udGV4dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90cmVlJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFJlbmRlcmVyMixcbiAgU2ltcGxlQ2hhbmdlLFxuICBTaW1wbGVDaGFuZ2VzLFxuICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBOelNhZmVBbnkgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdHlwZXMnO1xuXG5pbXBvcnQgeyBOelRyZWVWaWV3IH0gZnJvbSAnLi90cmVlJztcblxuZXhwb3J0IGludGVyZmFjZSBOelRyZWVWaXJ0dWFsTm9kZURhdGE8VD4ge1xuICBkYXRhOiBUO1xuICBjb250ZXh0OiBDZGtUcmVlTm9kZU91dGxldENvbnRleHQ8VD47XG4gIG5vZGVEZWY6IENka1RyZWVOb2RlRGVmPFQ+O1xufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduei10cmVlLW5vZGU6bm90KFtidWlsdGluXSknLFxuICBleHBvcnRBczogJ256VHJlZU5vZGUnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtUcmVlTm9kZSwgdXNlRXhpc3Rpbmc6IE56VHJlZU5vZGVDb21wb25lbnQgfV0sXG4gIHRlbXBsYXRlOiBgXG4gICAgPG56LXRyZWUtbm9kZS1pbmRlbnRzIFtpbmRlbnRzXT1cImluZGVudHNcIiAqbmdJZj1cImluZGVudHMubGVuZ3RoXCI+PC9uei10cmVlLW5vZGUtaW5kZW50cz5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuei10cmVlLW5vZGUtdG9nZ2xlLCBbbnotdHJlZS1ub2RlLXRvZ2dsZV1cIj48L25nLWNvbnRlbnQ+XG4gICAgPG56LXRyZWUtbm9kZS10b2dnbGUgY2xhc3M9XCJuei10cmVlLWxlYWYtbGluZS1pY29uXCIgKm5nSWY9XCJpbmRlbnRzLmxlbmd0aCAmJiBpc0xlYWZcIiBuelRyZWVOb2RlTm9vcFRvZ2dsZT5cbiAgICAgIDxzcGFuIGNsYXNzPVwiYW50LXRyZWUtc3dpdGNoZXItbGVhZi1saW5lXCI+PC9zcGFuPlxuICAgIDwvbnotdHJlZS1ub2RlLXRvZ2dsZT5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuei10cmVlLW5vZGUtY2hlY2tib3hcIj48L25nLWNvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibnotdHJlZS1ub2RlLW9wdGlvblwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmFudC10cmVlLXRyZWVub2RlLXN3aXRjaGVyLW9wZW5dJzogJ2lzRXhwYW5kZWQnLFxuICAgICdbY2xhc3MuYW50LXRyZWUtdHJlZW5vZGUtc3dpdGNoZXItY2xvc2VdJzogJyFpc0V4cGFuZGVkJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIE56VHJlZU5vZGVDb21wb25lbnQ8VD4gZXh0ZW5kcyBDZGtUcmVlTm9kZTxUPiBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgaW5kZW50czogYm9vbGVhbltdID0gW107XG4gIGRpc2FibGVkID0gZmFsc2U7XG4gIHNlbGVjdGVkID0gZmFsc2U7XG4gIGlzTGVhZiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICBwcm90ZWN0ZWQgdHJlZTogTnpUcmVlVmlldzxUPixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmXG4gICkge1xuICAgIHN1cGVyKGVsZW1lbnRSZWYsIHRyZWUpO1xuICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhbnQtdHJlZS10cmVlbm9kZScpO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5pc0xlYWYgPSAhdGhpcy50cmVlLnRyZWVDb250cm9sLmlzRXhwYW5kYWJsZSh0aGlzLmRhdGEpO1xuICB9XG5cbiAgZGlzYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZURpc2FibGVkQ2xhc3MoKTtcbiAgfVxuXG4gIGVuYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVEaXNhYmxlZENsYXNzKCk7XG4gIH1cblxuICBzZWxlY3QoKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVTZWxlY3RlZENsYXNzKCk7XG4gIH1cblxuICBkZXNlbGVjdCgpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTZWxlY3RlZENsYXNzKCk7XG4gIH1cblxuICBzZXRJbmRlbnRzKGluZGVudHM6IGJvb2xlYW5bXSk6IHZvaWQge1xuICAgIHRoaXMuaW5kZW50cyA9IGluZGVudHM7XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVNlbGVjdGVkQ2xhc3MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhbnQtdHJlZS10cmVlbm9kZS1zZWxlY3RlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnYW50LXRyZWUtdHJlZW5vZGUtc2VsZWN0ZWQnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZURpc2FibGVkQ2xhc3MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhbnQtdHJlZS10cmVlbm9kZS1kaXNhYmxlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnYW50LXRyZWUtdHJlZW5vZGUtZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW256VHJlZU5vZGVEZWZdJyxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtUcmVlTm9kZURlZiwgdXNlRXhpc3Rpbmc6IE56VHJlZU5vZGVEZWZEaXJlY3RpdmUgfV1cbn0pXG5leHBvcnQgY2xhc3MgTnpUcmVlTm9kZURlZkRpcmVjdGl2ZTxUPiBleHRlbmRzIENka1RyZWVOb2RlRGVmPFQ+IHtcbiAgQElucHV0KCduelRyZWVOb2RlRGVmV2hlbicpIHdoZW4hOiAoaW5kZXg6IG51bWJlciwgbm9kZURhdGE6IFQpID0+IGJvb2xlYW47XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuelRyZWVWaXJ0dWFsU2Nyb2xsTm9kZU91dGxldF0nXG59KVxuZXhwb3J0IGNsYXNzIE56VHJlZVZpcnR1YWxTY3JvbGxOb2RlT3V0bGV0RGlyZWN0aXZlPFQ+IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgcHJpdmF0ZSBfdmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPE56U2FmZUFueT4gfCBudWxsID0gbnVsbDtcbiAgQElucHV0KCkgZGF0YSE6IE56VHJlZVZpcnR1YWxOb2RlRGF0YTxUPjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKSB7fVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBjb25zdCByZWNyZWF0ZVZpZXcgPSB0aGlzLnNob3VsZFJlY3JlYXRlVmlldyhjaGFuZ2VzKTtcbiAgICBpZiAocmVjcmVhdGVWaWV3KSB7XG4gICAgICBjb25zdCB2aWV3Q29udGFpbmVyUmVmID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZjtcblxuICAgICAgaWYgKHRoaXMuX3ZpZXdSZWYpIHtcbiAgICAgICAgdmlld0NvbnRhaW5lclJlZi5yZW1vdmUodmlld0NvbnRhaW5lclJlZi5pbmRleE9mKHRoaXMuX3ZpZXdSZWYpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdmlld1JlZiA9IHRoaXMuZGF0YSA/IHZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuZGF0YS5ub2RlRGVmLnRlbXBsYXRlLCB0aGlzLmRhdGEuY29udGV4dCkgOiBudWxsO1xuXG4gICAgICBpZiAoQ2RrVHJlZU5vZGUubW9zdFJlY2VudFRyZWVOb2RlICYmIHRoaXMuX3ZpZXdSZWYpIHtcbiAgICAgICAgQ2RrVHJlZU5vZGUubW9zdFJlY2VudFRyZWVOb2RlLmRhdGEgPSB0aGlzLmRhdGEuZGF0YTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3ZpZXdSZWYgJiYgdGhpcy5kYXRhLmNvbnRleHQpIHtcbiAgICAgIHRoaXMudXBkYXRlRXhpc3RpbmdDb250ZXh0KHRoaXMuZGF0YS5jb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNob3VsZFJlY3JlYXRlVmlldyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogYm9vbGVhbiB7XG4gICAgY29uc3QgY3R4Q2hhbmdlID0gY2hhbmdlcy5kYXRhO1xuICAgIHJldHVybiAhIWNoYW5nZXMuZGF0YSB8fCAoY3R4Q2hhbmdlICYmIHRoaXMuaGFzQ29udGV4dFNoYXBlQ2hhbmdlZChjdHhDaGFuZ2UpKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFzQ29udGV4dFNoYXBlQ2hhbmdlZChjdHhDaGFuZ2U6IFNpbXBsZUNoYW5nZSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHByZXZDdHhLZXlzID0gT2JqZWN0LmtleXMoY3R4Q2hhbmdlLnByZXZpb3VzVmFsdWUgfHwge30pO1xuICAgIGNvbnN0IGN1cnJDdHhLZXlzID0gT2JqZWN0LmtleXMoY3R4Q2hhbmdlLmN1cnJlbnRWYWx1ZSB8fCB7fSk7XG5cbiAgICBpZiAocHJldkN0eEtleXMubGVuZ3RoID09PSBjdXJyQ3R4S2V5cy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcE5hbWUgb2YgY3VyckN0eEtleXMpIHtcbiAgICAgICAgaWYgKHByZXZDdHhLZXlzLmluZGV4T2YocHJvcE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVFeGlzdGluZ0NvbnRleHQoY3R4OiBOelNhZmVBbnkpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIE9iamVjdC5rZXlzKGN0eCkpIHtcbiAgICAgIHRoaXMuX3ZpZXdSZWYhLmNvbnRleHRbcHJvcE5hbWVdID0gKHRoaXMuZGF0YS5jb250ZXh0IGFzIE56U2FmZUFueSlbcHJvcE5hbWVdO1xuICAgIH1cbiAgfVxufVxuIl19