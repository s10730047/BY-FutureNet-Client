import { Directive, Input, Output, EventEmitter, } from '@angular/core';
import { AngularPaginatorService } from '../services/angular-paginator.service';
import * as i0 from "@angular/core";
import * as i1 from "../services/angular-paginator.service";
/**
 * This is the directive where the actual pagination takes place, it provides a sync between the
 * pipes and the pagination component
 */
export class AngularPaginatorDirective {
    /**
     *
     * @param angularPaginatorService serivce for angular paginator
     */
    constructor(angularPaginatorService) {
        this.angularPaginatorService = angularPaginatorService;
        /**
         * Use unique id when multiple paginations are being used on the same page.
         * By Default Paginator uses id `ANGULAR_PAGINATOR_DEFAULT`
         */
        this.id = AngularPaginatorService.id;
        /**
         * Whether to keep current page in the middle of the visible ones
         */
        this.rotate = false;
        /**
         * Whether to always display the first and last page numbers.
         * If max-size is smaller than the number of pages, then the first and last page numbers are still shown with ellipses
         * in-between as necessary. NOTE: max-size refers to the center of the range.
         * This option may add up to 2 more numbers on each side of the displayed range for the end value and
         * what would be an ellipsis but is replaced by a number because it is sequential
         */
        this.boundaryLinkNumbers = false;
        /**
         * Also displays ellipses when rotate is true and maxSize is smaller than the number of pages forceEllipses
         */
        this.forceEllipses = false;
        this.firstPage = 1;
        this.pages = [];
        /**
         * Emits an event whenever the current page is changed, It emits the current page number
         */
        this.pageChange = new EventEmitter(true);
        // subscribe to changes
        this.subscription = this.angularPaginatorService.change.subscribe((id) => {
            if (id === this.id) {
                this.updatePages();
            }
        });
    }
    /**
     * Navigate to prevoius page
     */
    toPreviousPage() {
        if (this.currentPage > this.firstPage) {
            this.setPage(this.currentPage - 1);
        }
    }
    /**
     * Navigate to next page
     */
    toNextPage() {
        if (this.currentPage < this.lastPage) {
            this.setPage(this.currentPage + 1);
        }
    }
    /**
     * Navigate to first page
     */
    toFirstPage() {
        this.setPage(this.firstPage);
    }
    /**
     * Navigate to last page
     */
    toLastPage() {
        this.setPage(this.lastPage);
    }
    /**
     * Sets current page
     *
     * @param page page number to set as currentPage
     */
    setCurrentPage(page) {
        this.setPage(page);
    }
    /**
     *
     * @param page  page number to set
     */
    setPage(page) {
        if (page && this.currentPage !== page) {
            this.currentPage = page;
            this.pageChange.emit(page);
        }
    }
    /**
     * create page object used for template
     *
     * @param pageNumber page number
     * @param text page number, text to be displayed
     * @param isActive whether the page is active or not, true for currentPage
     */
    makePage(pageNumber, text, isActive) {
        return {
            number: pageNumber,
            text,
            active: isActive,
        };
    }
    /**
     *  create page array
     *
     * @param currentPage current page number
     * @param itemsPerPage total items per page
     * @param totalItems no of items for pagination, usually array length
     */
    getPages(currentPage, itemsPerPage, totalItems) {
        const pages = [];
        // Default page limits
        const totalPages = this.lastPage = Math.ceil(totalItems / itemsPerPage);
        let startPage = 1;
        let endPage = totalPages;
        const isMaxSized = this.maxSize ? this.maxSize < totalPages : false;
        // recompute if maxSize
        if (isMaxSized && this.maxSize) {
            if (this.rotate) {
                // current page is displayed in the middle of the visible ones
                startPage = Math.max(currentPage - Math.floor(this.maxSize / 2), 1);
                endPage = startPage + this.maxSize - 1;
                // Adjust if limit is exceeded
                if (endPage > totalPages) {
                    endPage = totalPages;
                    startPage = endPage - this.maxSize + 1;
                }
            }
            else {
                // Visible pages are paginated with maxSize
                startPage = (Math.ceil(currentPage / this.maxSize) - 1) * this.maxSize + 1;
                // adjust last page if limit is exceeded
                endPage = Math.min(startPage + this.maxSize - 1, totalPages);
            }
        }
        // add page number links
        for (let pageNumber = startPage; pageNumber <= endPage; pageNumber++) {
            const page = this.makePage(pageNumber, pageNumber.toString(), pageNumber === currentPage);
            pages.push(page);
        }
        // add links to move between page sets
        if (isMaxSized && (this.maxSize && this.maxSize > 0) && (!this.rotate || this.forceEllipses || this.boundaryLinkNumbers)) {
            if (startPage > 1) {
                // need ellipsis for all options unless range is too close to beginning
                if (!this.boundaryLinkNumbers || startPage > 3) {
                    const previousPageSet = this.makePage(startPage - 1, '...', false);
                    pages.unshift(previousPageSet);
                }
                if (this.boundaryLinkNumbers) {
                    if (startPage === 3) { // need to replace ellipsis when the buttons would be sequential
                        const secondPageLink = this.makePage(2, '2', false);
                        pages.unshift(secondPageLink);
                    }
                    // add the first page
                    const firstPageLink = this.makePage(1, '1', false);
                    pages.unshift(firstPageLink);
                }
            }
            if (endPage < totalPages) {
                // need ellipsis for all options unless range is too close to end
                if (!this.boundaryLinkNumbers || endPage < totalPages - 2) {
                    const nextPageSet = this.makePage(endPage + 1, '...', false);
                    pages.push(nextPageSet);
                }
                if (this.boundaryLinkNumbers) {
                    // need to replace ellipsis when the buttons would be sequential
                    if (endPage === totalPages - 2) {
                        const secondToLastPageLink = this.makePage(totalPages - 1, (totalPages - 1).toString(), false);
                        pages.push(secondToLastPageLink);
                    }
                    // add the last page
                    const lastPageLink = this.makePage(totalPages, totalPages.toString(), false);
                    pages.push(lastPageLink);
                }
            }
        }
        return pages;
    }
    /**
     * Updates the pagination component
     */
    updatePages() {
        const instance = this.angularPaginatorService.getInstance(this.id);
        const correctedCurrentPage = this.outOfBoundCorrection(instance);
        if (correctedCurrentPage !== instance.currentPage || this.currentPage !== instance.currentPage) {
            this.setPage(correctedCurrentPage);
        }
        this.pages = this.getPages(instance.currentPage, instance.itemsPerPage, instance.totalItems);
    }
    /**
     * Check if currentPage is out of bound with totalPages
     *
     * @param instance instance for which the range is to be corrected
     */
    outOfBoundCorrection(instance) {
        const totalPages = Math.ceil(instance.totalItems / instance.itemsPerPage);
        if (totalPages < instance.currentPage && totalPages > 0) {
            return totalPages;
        }
        else if (instance.currentPage < 1) {
            return 1;
        }
        return instance.currentPage;
    }
    /**
     * check if there is any instance registered with the id
     */
    isValidId() {
        if (!this.angularPaginatorService.getInstance(this.id)) {
            throw new Error(`There is no instance registered with id \`${this.id}\``);
        }
    }
    ngOnInit() {
        this.isValidId();
        this.updatePages();
    }
    ngOnDestroy() {
        /** destroy the subscription when the directive is destroyed */
        this.subscription.unsubscribe();
    }
}
AngularPaginatorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.0.1", ngImport: i0, type: AngularPaginatorDirective, deps: [{ token: i1.AngularPaginatorService }], target: i0.ɵɵFactoryTarget.Directive });
AngularPaginatorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.0.1", type: AngularPaginatorDirective, selector: "angularPaginator, [angularPaginator]", inputs: { id: "id", maxSize: "maxSize", rotate: "rotate", boundaryLinkNumbers: "boundaryLinkNumbers", forceEllipses: "forceEllipses" }, outputs: { pageChange: "pageChange" }, exportAs: ["angularPaginator"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.0.1", ngImport: i0, type: AngularPaginatorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'angularPaginator, [angularPaginator]',
                    exportAs: 'angularPaginator',
                }]
        }], ctorParameters: function () { return [{ type: i1.AngularPaginatorService }]; }, propDecorators: { id: [{
                type: Input
            }], maxSize: [{
                type: Input
            }], rotate: [{
                type: Input
            }], boundaryLinkNumbers: [{
                type: Input
            }], forceEllipses: [{
                type: Input
            }], pageChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1wYWdpbmF0b3IuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1wYWdpbmF0b3Ivc3JjL2xpYi9kaXJlY3RpdmVzL2FuZ3VsYXItcGFnaW5hdG9yLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUFxQixLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksR0FDMUQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sdUNBQXVDLENBQUM7OztBQUloRjs7O0dBR0c7QUFNSCxNQUFNLE9BQU8seUJBQXlCO0lBMkNwQzs7O09BR0c7SUFDSCxZQUFvQix1QkFBZ0Q7UUFBaEQsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUF5QjtRQTlDcEU7OztXQUdHO1FBQ00sT0FBRSxHQUFXLHVCQUF1QixDQUFDLEVBQUUsQ0FBQztRQU9qRDs7V0FFRztRQUNNLFdBQU0sR0FBRyxLQUFLLENBQUM7UUFFeEI7Ozs7OztXQU1HO1FBQ00sd0JBQW1CLEdBQUcsS0FBSyxDQUFDO1FBRXJDOztXQUVHO1FBQ00sa0JBQWEsR0FBRyxLQUFLLENBQUM7UUFHL0IsY0FBUyxHQUFHLENBQUMsQ0FBQztRQUVkLFVBQUssR0FBVyxFQUFFLENBQUM7UUFJbkI7O1dBRUc7UUFDTyxlQUFVLEdBQXlCLElBQUksWUFBWSxDQUFTLElBQUksQ0FBQyxDQUFDO1FBTzFFLHVCQUF1QjtRQUN2QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBVSxFQUFFLEVBQUU7WUFDL0UsSUFBSSxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsRUFBRTtnQkFDbEIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQ3BCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxD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UUFBUTtRQUNOLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNqQixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVELFdBQVc7UUFDVCwrREFBK0Q7UUFDL0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNsQyxDQUFDOztzSEFwUVUseUJBQXlCOzBHQUF6Qix5QkFBeUI7MkZBQXpCLHlCQUF5QjtrQkFMckMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsc0NBQXNDO29CQUNoRCxRQUFRLEVBQUUsa0JBQWtCO2lCQUM3Qjs4R0FPVSxFQUFFO3NCQUFWLEtBQUs7Z0JBS0csT0FBTztzQkFBZixLQUFLO2dCQUtHLE1BQU07c0JBQWQsS0FBSztnQkFTRyxtQkFBbUI7c0JBQTNCLEtBQUs7Z0JBS0csYUFBYTtzQkFBckIsS0FBSztnQkFZSSxVQUFVO3NCQUFuQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLCBPbkluaXQsIE9uRGVzdHJveSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvYW5ndWxhci1wYWdpbmF0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBBbmd1bGFyUGFnaW5hdG9ySW5zdGFuY2UsIFBhZ2UgfSBmcm9tICcuLi9vdGhlcnMvYW5ndWxhci1wYWdpbmF0b3IuaW50ZXJmYWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGRpcmVjdGl2ZSB3aGVyZSB0aGUgYWN0dWFsIHBhZ2luYXRpb24gdGFrZXMgcGxhY2UsIGl0IHByb3ZpZGVzIGEgc3luYyBiZXR3ZWVuIHRoZVxuICogcGlwZXMgYW5kIHRoZSBwYWdpbmF0aW9uIGNvbXBvbmVudFxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdhbmd1bGFyUGFnaW5hdG9yLCBbYW5ndWxhclBhZ2luYXRvcl0nLFxuICBleHBvcnRBczogJ2FuZ3VsYXJQYWdpbmF0b3InLFxufSlcblxuZXhwb3J0IGNsYXNzIEFuZ3VsYXJQYWdpbmF0b3JEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBVc2UgdW5pcXVlIGlkIHdoZW4gbXVsdGlwbGUgcGFnaW5hdGlvbnMgYXJlIGJlaW5nIHVzZWQgb24gdGhlIHNhbWUgcGFnZS5cbiAgICogQnkgRGVmYXVsdCBQYWdpbmF0b3IgdXNlcyBpZCBgQU5HVUxBUl9QQUdJTkFUT1JfREVGQVVMVGBcbiAgICovXG4gIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSBBbmd1bGFyUGFnaW5hdG9yU2VydmljZS5pZDtcblxuICAvKipcbiAgICogTGltaXQgbnVtYmVyIGZvciBwYWdpbmF0aW9uIHNpemUsIGkuZS4sIHRoZSBtYXhpbXVtIHBhZ2UgbnVtYmVycyB0byBiZSBkaXNwbGF5ZWRcbiAgICovXG4gIEBJbnB1dCgpIG1heFNpemU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8ga2VlcCBjdXJyZW50IHBhZ2UgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXG4gICAqL1xuICBASW5wdXQoKSByb3RhdGUgPSBmYWxzZTtcblxuICAvKipcbiAgICogV2hldGhlciB0byBhbHdheXMgZGlzcGxheSB0aGUgZmlyc3QgYW5kIGxhc3QgcGFnZSBudW1iZXJzLlxuICAgKiBJZiBtYXgtc2l6ZSBpcyBzbWFsbGVyIHRoYW4gdGhlIG51bWJlciBvZiBwYWdlcywgdGhlbiB0aGUgZmlyc3QgYW5kIGxhc3QgcGFnZSBudW1iZXJzIGFyZSBzdGlsbCBzaG93biB3aXRoIGVsbGlwc2VzXG4gICAqIGluLWJldHdlZW4gYXMgbmVjZXNzYXJ5LiBOT1RFOiBtYXgtc2l6ZSByZWZlcnMgdG8gdGhlIGNlbnRlciBvZiB0aGUgcmFuZ2UuXG4gICAqIFRoaXMgb3B0aW9uIG1heSBhZGQgdXAgdG8gMiBtb3JlIG51bWJlcnMgb24gZWFjaCBzaWRlIG9mIHRoZSBkaXNwbGF5ZWQgcmFuZ2UgZm9yIHRoZSBlbmQgdmFsdWUgYW5kXG4gICAqIHdoYXQgd291bGQgYmUgYW4gZWxsaXBzaXMgYnV0IGlzIHJlcGxhY2VkIGJ5IGEgbnVtYmVyIGJlY2F1c2UgaXQgaXMgc2VxdWVudGlhbFxuICAgKi9cbiAgQElucHV0KCkgYm91bmRhcnlMaW5rTnVtYmVycyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBbHNvIGRpc3BsYXlzIGVsbGlwc2VzIHdoZW4gcm90YXRlIGlzIHRydWUgYW5kIG1heFNpemUgaXMgc21hbGxlciB0aGFuIHRoZSBudW1iZXIgb2YgcGFnZXMgZm9yY2VFbGxpcHNlc1xuICAgKi9cbiAgQElucHV0KCkgZm9yY2VFbGxpcHNlcyA9IGZhbHNlO1xuXG4gIGN1cnJlbnRQYWdlITogbnVtYmVyO1xuICBmaXJzdFBhZ2UgPSAxO1xuICBsYXN0UGFnZSE6IG51bWJlcjtcbiAgcGFnZXM6IFBhZ2VbXSA9IFtdO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW5ldmVyIHRoZSBjdXJyZW50IHBhZ2UgaXMgY2hhbmdlZCwgSXQgZW1pdHMgdGhlIGN1cnJlbnQgcGFnZSBudW1iZXJcbiAgICovXG4gIEBPdXRwdXQoKSBwYWdlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPih0cnVlKTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGFuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlIHNlcml2Y2UgZm9yIGFuZ3VsYXIgcGFnaW5hdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlOiBBbmd1bGFyUGFnaW5hdG9yU2VydmljZSkge1xuICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmFuZ3VsYXJQYWdpbmF0b3JTZXJ2aWNlLmNoYW5nZS5zdWJzY3JpYmUoKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChpZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gcHJldm9pdXMgcGFnZVxuICAgKi9cbiAgdG9QcmV2aW91c1BhZ2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPiB0aGlzLmZpcnN0UGFnZSkge1xuICAgICAgdGhpcy5zZXRQYWdlKHRoaXMuY3VycmVudFBhZ2UgLSAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gbmV4dCBwYWdlXG4gICAqL1xuICB0b05leHRQYWdlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlIDwgdGhpcy5sYXN0UGFnZSkge1xuICAgICAgdGhpcy5zZXRQYWdlKHRoaXMuY3VycmVudFBhZ2UgKyAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gZmlyc3QgcGFnZVxuICAgKi9cbiAgdG9GaXJzdFBhZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5zZXRQYWdlKHRoaXMuZmlyc3RQYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byBsYXN0IHBhZ2VcbiAgICovXG4gIHRvTGFzdFBhZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5zZXRQYWdlKHRoaXMubGFzdFBhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgY3VycmVudCBwYWdlXG4gICAqXG4gICAqIEBwYXJhbSBwYWdlIHBhZ2UgbnVtYmVyIHRvIHNldCBhcyBjdXJyZW50UGFnZVxuICAgKi9cbiAgc2V0Q3VycmVudFBhZ2UocGFnZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zZXRQYWdlKHBhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBwYWdlICBwYWdlIG51bWJlciB0byBzZXRcbiAgICovXG4gIHByaXZhdGUgc2V0UGFnZShwYWdlOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAocGFnZSAmJiB0aGlzLmN1cnJlbnRQYWdlICE9PSBwYWdlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYWdlID0gcGFnZTtcbiAgICAgIHRoaXMucGFnZUNoYW5nZS5lbWl0KHBhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGUgcGFnZSBvYmplY3QgdXNlZCBmb3IgdGVtcGxhdGVcbiAgICpcbiAgICogQHBhcmFtIHBhZ2VOdW1iZXIgcGFnZSBudW1iZXJcbiAgICogQHBhcmFtIHRleHQgcGFnZSBudW1iZXIsIHRleHQgdG8gYmUgZGlzcGxheWVkXG4gICAqIEBwYXJhbSBpc0FjdGl2ZSB3aGV0aGVyIHRoZSBwYWdlIGlzIGFjdGl2ZSBvciBub3QsIHRydWUgZm9yIGN1cnJlbnRQYWdlXG4gICAqL1xuICBwcml2YXRlIG1ha2VQYWdlKHBhZ2VOdW1iZXI6IG51bWJlciwgdGV4dDogc3RyaW5nLCBpc0FjdGl2ZTogYm9vbGVhbik6IFBhZ2Uge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IHBhZ2VOdW1iZXIsXG4gICAgICB0ZXh0LFxuICAgICAgYWN0aXZlOiBpc0FjdGl2ZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqICBjcmVhdGUgcGFnZSBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudFBhZ2UgY3VycmVudCBwYWdlIG51bWJlclxuICAgKiBAcGFyYW0gaXRlbXNQZXJQYWdlIHRvdGFsIGl0ZW1zIHBlciBwYWdlXG4gICAqIEBwYXJhbSB0b3RhbEl0ZW1zIG5vIG9mIGl0ZW1zIGZvciBwYWdpbmF0aW9uLCB1c3VhbGx5IGFycmF5IGxlbmd0aFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRQYWdlcyhjdXJyZW50UGFnZTogbnVtYmVyLCBpdGVtc1BlclBhZ2U6IG51bWJlciwgdG90YWxJdGVtczogbnVtYmVyKTogUGFnZVtdIHtcbiAgICBjb25zdCBwYWdlczogUGFnZVtdID0gW107XG5cbiAgICAvLyBEZWZhdWx0IHBhZ2UgbGltaXRzXG4gICAgY29uc3QgdG90YWxQYWdlczogbnVtYmVyID0gdGhpcy5sYXN0UGFnZSA9IE1hdGguY2VpbCh0b3RhbEl0ZW1zIC8gaXRlbXNQZXJQYWdlKTtcblxuICAgIGxldCBzdGFydFBhZ2UgPSAxO1xuICAgIGxldCBlbmRQYWdlOiBudW1iZXIgPSB0b3RhbFBhZ2VzO1xuICAgIGNvbnN0IGlzTWF4U2l6ZWQ6IGJvb2xlYW4gPSB0aGlzLm1heFNpemUgPyB0aGlzLm1heFNpemUgPCB0b3RhbFBhZ2VzIDogZmFsc2U7XG5cbiAgICAvLyByZWNvbXB1dGUgaWYgbWF4U2l6ZVxuICAgIGlmIChpc01heFNpemVkICYmIHRoaXMubWF4U2l6ZSkge1xuICAgICAgaWYgKHRoaXMucm90YXRlKSB7XG4gICAgICAgIC8vIGN1cnJlbnQgcGFnZSBpcyBkaXNwbGF5ZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXG4gICAgICAgIHN0YXJ0UGFnZSA9IE1hdGgubWF4KGN1cnJlbnRQYWdlIC0gTWF0aC5mbG9vcih0aGlzLm1heFNpemUgLyAyKSwgMSk7XG4gICAgICAgIGVuZFBhZ2UgPSBzdGFydFBhZ2UgKyB0aGlzLm1heFNpemUgLSAxO1xuXG4gICAgICAgIC8vIEFkanVzdCBpZiBsaW1pdCBpcyBleGNlZWRlZFxuICAgICAgICBpZiAoZW5kUGFnZSA+IHRvdGFsUGFnZXMpIHtcbiAgICAgICAgICBlbmRQYWdlID0gdG90YWxQYWdlcztcbiAgICAgICAgICBzdGFydFBhZ2UgPSBlbmRQYWdlIC0gdGhpcy5tYXhTaXplICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVmlzaWJsZSBwYWdlcyBhcmUgcGFnaW5hdGVkIHdpdGggbWF4U2l6ZVxuICAgICAgICBzdGFydFBhZ2UgPSAoTWF0aC5jZWlsKGN1cnJlbnRQYWdlIC8gdGhpcy5tYXhTaXplKSAtIDEpICogdGhpcy5tYXhTaXplICsgMTtcblxuICAgICAgICAvLyBhZGp1c3QgbGFzdCBwYWdlIGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgICAgIGVuZFBhZ2UgPSBNYXRoLm1pbihzdGFydFBhZ2UgKyB0aGlzLm1heFNpemUgLSAxLCB0b3RhbFBhZ2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgcGFnZSBudW1iZXIgbGlua3NcbiAgICBmb3IgKGxldCBwYWdlTnVtYmVyID0gc3RhcnRQYWdlOyBwYWdlTnVtYmVyIDw9IGVuZFBhZ2U7IHBhZ2VOdW1iZXIrKykge1xuICAgICAgY29uc3QgcGFnZSA9IHRoaXMubWFrZVBhZ2UocGFnZU51bWJlciwgcGFnZU51bWJlci50b1N0cmluZygpLCBwYWdlTnVtYmVyID09PSBjdXJyZW50UGFnZSk7XG4gICAgICBwYWdlcy5wdXNoKHBhZ2UpO1xuICAgIH1cblxuICAgIC8vIGFkZCBsaW5rcyB0byBtb3ZlIGJldHdlZW4gcGFnZSBzZXRzXG4gICAgaWYgKGlzTWF4U2l6ZWQgJiYgKHRoaXMubWF4U2l6ZSAmJiB0aGlzLm1heFNpemUgPiAwKSAmJiAoIXRoaXMucm90YXRlIHx8IHRoaXMuZm9yY2VFbGxpcHNlcyB8fCB0aGlzLmJvdW5kYXJ5TGlua051bWJlcnMpKSB7XG4gICAgICBpZiAoc3RhcnRQYWdlID4gMSkge1xuICAgICAgICAvLyBuZWVkIGVsbGlwc2lzIGZvciBhbGwgb3B0aW9ucyB1bmxlc3MgcmFuZ2UgaXMgdG9vIGNsb3NlIHRvIGJlZ2lubmluZ1xuICAgICAgICBpZiAoIXRoaXMuYm91bmRhcnlMaW5rTnVtYmVycyB8fCBzdGFydFBhZ2UgPiAzKSB7XG4gICAgICAgICAgY29uc3QgcHJldmlvdXNQYWdlU2V0ID0gdGhpcy5tYWtlUGFnZShzdGFydFBhZ2UgLSAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnVuc2hpZnQocHJldmlvdXNQYWdlU2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5TGlua051bWJlcnMpIHtcbiAgICAgICAgICBpZiAoc3RhcnRQYWdlID09PSAzKSB7IC8vIG5lZWQgdG8gcmVwbGFjZSBlbGxpcHNpcyB3aGVuIHRoZSBidXR0b25zIHdvdWxkIGJlIHNlcXVlbnRpYWxcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFBhZ2VMaW5rID0gdGhpcy5tYWtlUGFnZSgyLCAnMicsIGZhbHNlKTtcbiAgICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoc2Vjb25kUGFnZUxpbmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCB0aGUgZmlyc3QgcGFnZVxuICAgICAgICAgIGNvbnN0IGZpcnN0UGFnZUxpbmsgPSB0aGlzLm1ha2VQYWdlKDEsICcxJywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnVuc2hpZnQoZmlyc3RQYWdlTGluayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFBhZ2UgPCB0b3RhbFBhZ2VzKSB7XG4gICAgICAgIC8vIG5lZWQgZWxsaXBzaXMgZm9yIGFsbCBvcHRpb25zIHVubGVzcyByYW5nZSBpcyB0b28gY2xvc2UgdG8gZW5kXG4gICAgICAgIGlmICghdGhpcy5ib3VuZGFyeUxpbmtOdW1iZXJzIHx8IGVuZFBhZ2UgPCB0b3RhbFBhZ2VzIC0gMikge1xuICAgICAgICAgIGNvbnN0IG5leHRQYWdlU2V0ID0gdGhpcy5tYWtlUGFnZShlbmRQYWdlICsgMSwgJy4uLicsIGZhbHNlKTtcbiAgICAgICAgICBwYWdlcy5wdXNoKG5leHRQYWdlU2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5TGlua051bWJlcnMpIHtcbiAgICAgICAgICAvLyBuZWVkIHRvIHJlcGxhY2UgZWxsaXBzaXMgd2hlbiB0aGUgYnV0dG9ucyB3b3VsZCBiZSBzZXF1ZW50aWFsXG4gICAgICAgICAgaWYgKGVuZFBhZ2UgPT09IHRvdGFsUGFnZXMgLSAyKSB7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRUb0xhc3RQYWdlTGluayA9IHRoaXMubWFrZVBhZ2UodG90YWxQYWdlcyAtIDEsICh0b3RhbFBhZ2VzIC0gMSkudG9TdHJpbmcoKSwgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMucHVzaChzZWNvbmRUb0xhc3RQYWdlTGluayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHRoZSBsYXN0IHBhZ2VcbiAgICAgICAgICBjb25zdCBsYXN0UGFnZUxpbmsgPSB0aGlzLm1ha2VQYWdlKHRvdGFsUGFnZXMsIHRvdGFsUGFnZXMudG9TdHJpbmcoKSwgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnB1c2gobGFzdFBhZ2VMaW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFnZXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGFnaW5hdGlvbiBjb21wb25lbnRcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlUGFnZXMoKTogdm9pZCB7XG4gICAgY29uc3QgaW5zdGFuY2U6IEFuZ3VsYXJQYWdpbmF0b3JJbnN0YW5jZSA9IHRoaXMuYW5ndWxhclBhZ2luYXRvclNlcnZpY2UuZ2V0SW5zdGFuY2UodGhpcy5pZCk7XG5cbiAgICBjb25zdCBjb3JyZWN0ZWRDdXJyZW50UGFnZSA9IHRoaXMub3V0T2ZCb3VuZENvcnJlY3Rpb24oaW5zdGFuY2UpO1xuXG4gICAgaWYgKGNvcnJlY3RlZEN1cnJlbnRQYWdlICE9PSBpbnN0YW5jZS5jdXJyZW50UGFnZSB8fCB0aGlzLmN1cnJlbnRQYWdlICE9PSBpbnN0YW5jZS5jdXJyZW50UGFnZSkge1xuICAgICAgdGhpcy5zZXRQYWdlKGNvcnJlY3RlZEN1cnJlbnRQYWdlKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhZ2VzID0gdGhpcy5nZXRQYWdlcyhpbnN0YW5jZS5jdXJyZW50UGFnZSwgaW5zdGFuY2UuaXRlbXNQZXJQYWdlLCBpbnN0YW5jZS50b3RhbEl0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBjdXJyZW50UGFnZSBpcyBvdXQgb2YgYm91bmQgd2l0aCB0b3RhbFBhZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBpbnN0YW5jZSBpbnN0YW5jZSBmb3Igd2hpY2ggdGhlIHJhbmdlIGlzIHRvIGJlIGNvcnJlY3RlZFxuICAgKi9cbiAgcHJpdmF0ZSBvdXRPZkJvdW5kQ29ycmVjdGlvbihpbnN0YW5jZTogQW5ndWxhclBhZ2luYXRvckluc3RhbmNlKTogbnVtYmVyIHtcbiAgICBjb25zdCB0b3RhbFBhZ2VzID0gTWF0aC5jZWlsKGluc3RhbmNlLnRvdGFsSXRlbXMgLyBpbnN0YW5jZS5pdGVtc1BlclBhZ2UpO1xuXG4gICAgaWYgKHRvdGFsUGFnZXMgPCBpbnN0YW5jZS5jdXJyZW50UGFnZSAmJiB0b3RhbFBhZ2VzID4gMCkge1xuICAgICAgcmV0dXJuIHRvdGFsUGFnZXM7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5jdXJyZW50UGFnZSA8IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZS5jdXJyZW50UGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVjayBpZiB0aGVyZSBpcyBhbnkgaW5zdGFuY2UgcmVnaXN0ZXJlZCB3aXRoIHRoZSBpZFxuICAgKi9cbiAgaXNWYWxpZElkKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5hbmd1bGFyUGFnaW5hdG9yU2VydmljZS5nZXRJbnN0YW5jZSh0aGlzLmlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBpbnN0YW5jZSByZWdpc3RlcmVkIHdpdGggaWQgXFxgJHt0aGlzLmlkfVxcYGApO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuaXNWYWxpZElkKCk7XG4gICAgdGhpcy51cGRhdGVQYWdlcygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgLyoqIGRlc3Ryb3kgdGhlIHN1YnNjcmlwdGlvbiB3aGVuIHRoZSBkaXJlY3RpdmUgaXMgZGVzdHJveWVkICovXG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19